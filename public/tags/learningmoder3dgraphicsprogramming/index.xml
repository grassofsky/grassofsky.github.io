<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Learningmoder3dgraphicsprogramming on Stupidgrass&#39;s Notepad Online</title>
    <link>https://stupidgrass.github.io/tags/learningmoder3dgraphicsprogramming/</link>
    <description>Recent content in Learningmoder3dgraphicsprogramming on Stupidgrass&#39;s Notepad Online</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 30 May 2015 12:00:00 +0600</lastBuildDate>
    
	<atom:link href="https://stupidgrass.github.io/tags/learningmoder3dgraphicsprogramming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>6. opengl使用不同的缓存对象</title>
      <link>https://stupidgrass.github.io/blog/learningmodern3dgraphicsprogramming/6_various_buffer_object/</link>
      <pubDate>Sat, 30 May 2015 12:00:00 +0600</pubDate>
      
      <guid>https://stupidgrass.github.io/blog/learningmodern3dgraphicsprogramming/6_various_buffer_object/</guid>
      <description>opengl使用不同的缓存对象 在设置颜色一章中，我们使用了一个缓存对象来存储点和颜色的信息。那么我们有没有可能，将点和颜色的信息分开存储呢？这在实际应用中也许可以使得各个属性之间保持相互的独立。本章补充内容需要做的事情就是这个。
相对于上一章需要改变的内容有 顶点属性和颜色分别独立存储：
const float vertex[] = { 0.0f, 0.5f, 0.0f, 1.0f, 0.5f, -0.366f, 0.0f, 1.0f, -0.5f, -0.366f, 0.0f, 1.0f, }; const float color[] = { 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f };  Vertex Array Object 上一章中，绘制图像所需的数据都存储在Vertex Buffer Object中，然后利用glVertexAttribPointer来告诉opengl该缓存对象中的哪个数据段是顶点位置属性，哪些数据段是颜色属性。如果想要将多个属性分别存储于独立的VBO中，那么此处就需要VAO出马上任了。VAO能够用来存储多个VBO对象的对象。它被设计用来存储用于完成对象渲染所需要的信息：这里包括，数据，数据格式，以及不同的数据对应的着色器中的location。
于是将上一章中的InitializeVertexBuffer改成InitializeVAO
void InitializeVAO() { glGenVertexArrays(1, &amp;amp;vao); glBindVertexArray(vao); glGenBuffers(1, &amp;amp;positionBufferObject); glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject); glBufferData(GL__ARRAY_BUFFER, sizeof(vertexData), vertexData, GL_STATIC_DRAW); glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0); glGenBuffers(1, &amp;amp;colorBufferObject); glBindBuffer(GL_ARRAY_BUFFER, colorBufferObject); glBufferData(GL_ARRAY_BUFFER, sizeof(colorData), colorData, GL_STATIC_DRAW); glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0); glBindBuffer(GL_ARRAY_BUFFER, 0); }  同时display中的代码也需要进行如下的修改：</description>
    </item>
    
  </channel>
</rss>