<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>4. 你好，三角形 - grassofsky notebook</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="grassofsky" /><meta name="description" content="你好，三角形 传统的入门教程在介绍编程语言的时候，通常从“Hello，World！”的程序开始。这样的程序拥有最简单的能够直接输出“Hello" /><meta name="keywords" content="grassofsky, notebook" />






<meta name="generator" content="Hugo 0.62.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/learningmodern3dgraphicsprogramming/4_hello_triangle/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="4. 你好，三角形" />
<meta property="og:description" content="你好，三角形 传统的入门教程在介绍编程语言的时候，通常从“Hello，World！”的程序开始。这样的程序拥有最简单的能够直接输出“Hello" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/learningmodern3dgraphicsprogramming/4_hello_triangle/" />
<meta property="article:published_time" content="2017-05-30T12:00:00+06:00" />
<meta property="article:modified_time" content="2017-05-30T12:00:00+06:00" />
<meta itemprop="name" content="4. 你好，三角形">
<meta itemprop="description" content="你好，三角形 传统的入门教程在介绍编程语言的时候，通常从“Hello，World！”的程序开始。这样的程序拥有最简单的能够直接输出“Hello">
<meta itemprop="datePublished" content="2017-05-30T12:00:00&#43;06:00" />
<meta itemprop="dateModified" content="2017-05-30T12:00:00&#43;06:00" />
<meta itemprop="wordCount" content="10232">



<meta itemprop="keywords" content="opengl,LearningModern3DGraphicsProgramming," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="4. 你好，三角形"/>
<meta name="twitter:description" content="你好，三角形 传统的入门教程在介绍编程语言的时候，通常从“Hello，World！”的程序开始。这样的程序拥有最简单的能够直接输出“Hello"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">4. 你好，三角形</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-05-30 </span>
        <div class="post-category">
            <a href="/categories/translation-of-books/"> Translation of books </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#heading-1">本章例子中的代码</a></li>
    <li><a href="#display">display函数详解</a></li>
    <li><a href="#heading-2">跟着数据走</a>
      <ul>
        <li><a href="#heading-3">顶点传输</a></li>
        <li><a href="#heading-4">顶点处理和着色器</a></li>
        <li><a href="#heading-5">光栅化</a></li>
        <li><a href="#heading-6">片段处理</a></li>
      </ul>
    </li>
    <li><a href="#heading-7">生成着色器</a></li>
    <li><a href="#heading-8">清理工作</a></li>
    <li><a href="#heading-9">回顾</a>
      <ul>
        <li><a href="#opengl">opengl函数</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="heading">你好，三角形</h1>
<p>传统的入门教程在介绍编程语言的时候，通常从“Hello，World！”的程序开始。这样的程序拥有最简单的能够直接输出“Hello, World!”的代码。这是一种熟悉编译系统以及代码执行的很好的一种方式。</p>
<p>使用opengl来写实际的文本的具有一定难度的。在第一章中，我们采用将三角形绘制到屏幕上还取代文本的输出。</p>
<h2 id="heading-1">本章例子中的代码</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;GL/glew.h&gt;
#include &lt;GL/glut.h&gt;
#include &lt;GL/gl.h&gt;

GLuint positionBufferObject;
GLuint theProgram;
const float vertexPositions[] = {
	0.75f, 0.75f, 0.0f, 1.0f,
	0.75f, -0.75f, 0.0f, 1.0f,
	-0.75f, -0.75f, 0.0f, 1.0f,
};

void InitializeVertexBuffer()
{
    glGenBuffers(1, &amp;positionBufferObject);

    glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexPositions), vertexPositions, GL_STATIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
}

GLuint CreateShader(GLenum eShaderType, const std::string &amp;strShaderFilename)
{
    GLuint shader = glCreateShader(eShaderType);
    std::ifstream ifile(strShaderFilename.c_str());
    std::stringstream buffer;
    buffer &lt;&lt; ifile.rdbuf();
    std::string contents(buffer.str());
    const char* pContents = contents.c_str();

    glShaderSource(shader, 1, &amp;pContents, NULL);

    glCompileShader(shader);
    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;status);
    if (status == GL_FALSE)
    {
        GLint infoLogLength;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;infoLogLength);
        GLchar *strInfoLog = new GLchar[infoLogLength+1];
        glGetShaderInfoLog(shader, infoLogLength, NULL, strInfoLog);
        fprintf(stderr, &#34;Compile failure in %d shader: \n%s\n&#34;, eShaderType, strInfoLog);
        delete[] strInfoLog;
    }
    return shader;
}

GLuint CreateProgram(const std::vector&lt;GLuint&gt;&amp; vecShader)
{
    GLuint program = glCreateProgram();
    for (size_t i=0; i&lt;vecShader.size(); ++i)
    {
        glAttachShader(program, vecShader[i]);
    }

    glLinkProgram(program);

    GLint status;
    glGetProgramiv(program, GL_LINK_STATUS, &amp;status);
    if (status == GL_FALSE)
    {
        GLint infoLogLength;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;infoLogLength);
        printf(&#34;Log length: %d\n&#34;, infoLogLength);
        GLchar *strInfoLog = new GLchar[infoLogLength+1];
        glGetProgramInfoLog(program, infoLogLength, NULL, strInfoLog);
        fprintf(stderr, &#34;Linker failure: %s\n&#34;, strInfoLog);
        delete[] strInfoLog;
    }

    for (size_t i=0; i&lt;vecShader.size(); i++)
    {
        glDetachShader(program, vecShader[i]);
    }
    return program;
}


void InitializeProgram()
{
    std::vector&lt;GLuint&gt; shaderList;
    shaderList.push_back(CreateShader(GL_VERTEX_SHADER, &#34;./triangle.vert&#34;));
    shaderList.push_back(CreateShader(GL_FRAGMENT_SHADER, &#34;./triangle.frag&#34;));

    theProgram = CreateProgram(shaderList);
    std::for_each(shaderList.begin(), shaderList.end(), glDeleteShader);
}

void init()
{
    InitializeProgram();
    InitializeVertexBuffer();
}

void reshape(int w, int h)
{
    glViewport(0, 0, (GLsizei)w, (GLsizei)h);
}

void display()
{
    glClearColor(0.0f, 0.0f, 0.0f,0.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glUseProgram(theProgram);
    glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0,4,GL_FLOAT,GL_FALSE,0,0);
    glDrawArrays(GL_TRIANGLES, 0, 3);
    glDisableVertexAttribArray(0);
    glUseProgram(0);
    glutSwapBuffers();
}


int main(int argc, char** argv)
{
    glutInit(&amp;argc, argv);

    int width = 500;
    int height = 500;

    glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH);
    glutInitWindowSize(width, height);
    glutInitWindowPosition(300,200);
    int window = glutCreateWindow(argv[0]);

    GLenum err = glewInit();
    if (err != GLEW_OK)
    {
        std::cout &lt;&lt; &#34;glewInit failed: &#34; &lt;&lt; glewGetErrorString(err) &lt;&lt; std::endl;
    }

    init();
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    /* glutKeyboardFunc(keyboard); */
    glutMainLoop();
    return 0;
}
</code></pre></td></tr></table>
</div>
</div><h2 id="display">display函数详解</h2>
<p><code>display</code>函数从表面上来看是非常简单的。但是，它的功能是非常复杂的，并且和<code>init</code>中的初始化过程有关系。在阅读过程中对于暂时不理解的地方不用纠结，略过继续看即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// Example 1.1. The display Function
glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
glClear(GL_COLOR_BUFFER_BIT);

glUseProgram(theProgram);

glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
glEnableVertexAttribArray(0);
glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);

glDrawArrays(GL_TRIANGLES, 0, 3);

glDisableVertexAttribArray(0);
glUseProgram(0);

glutSwapBuffers();
</code></pre></td></tr></table>
</div>
</div><p>前两行用来清空屏幕。<code>glClearColor</code>是其中一个状态设置函数，它用来设置清空屏幕的时候使用的颜色。此处将清空颜色设置成了黑色。<code>glClear</code>并没有设置opengl的状态，它用来触发屏幕清空操作。其中<code>GL_COLOR_BUFFER_BIT</code>参数表示这次清空操作会影响到颜色缓存区，将颜色缓存区中的颜色设置成上述设定的黑色。</p>
<p>接下来的一行代码是用来设置当前的纹理程序，这个纹理程序会被接下去的渲染命令用到。在后面的内容中我们会详细阐述纹理程序是怎么工作的。</p>
<p>再接下去的三行指令都使用来设置opengl上下文中的状态的。这些命令设置了将被渲染的三角形的坐标。他们告诉opengl三角形坐标在内存中的位置。详细内容后续会深入介绍。</p>
<p><code>glDrawArrays</code>从命名上可以发现端倪，这是一个渲染相关的函数。根据当前设定的上下文中的状态，来绘制图形，参数中<code>GL_TRIANGLES</code>说明当前绘制的是三角形。</p>
<p>再接下去的两行是简单的清理工作，将渲染完后原先设置的一些参数清空。</p>
<p>最后一行，<code>glutSwapBuffers</code>，是<code>FreeGLUT</code>的命令，并不是opengl的命令。我们在程序中将opengl的帧缓存设定成了双缓存。这意味着当前显示图像的缓存和当前用于渲染的缓存是两个独立的缓存。因此，我们所有的渲染过程只有在渲染玩之后才会呈现给用户。也就是说，用户不会看到渲染一般的图像。<code>glutSwapBuffers</code>是用来将渲染得到的图像呈现给用户。</p>
<h2 id="heading-2">跟着数据走</h2>
<p>在<strong>基础简介</strong>的章节中，我们介绍了opengl管线的功能。这次我们将会依据代码再次对管线的内容进行介绍。这里将会更深次的理解到opengl渲染数据相关的细节。</p>
<h3 id="heading-3">顶点传输</h3>
<p>光栅化管线的第一个步骤是将顶点转换到裁剪空间。在opengl执行转换之前，必须接受到顶点的列表。因此该管线更初始的步骤是将三角形的顶点数据传输给opengl。</p>
<p>下面是将要被传输的顶点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">const float vertexPositions[] = {
    0.75f, 0.75f, 0.0f, 1.0f,
    0.75f, -0.75f, 0.0f, 1.0f,
    -0.75f, -0.75f, 0.0f, 1.0f,
}
</code></pre></td></tr></table>
</div>
</div><p>每一行都表示一个顶点的四维坐标。这些顶点是四维的原因是裁剪空间中的顶点是四维的。这些顶点已经是裁剪坐标系中的点了。现在我们想要让opengl根据这些点（三角形的三个定点）来渲染三角形。</p>
<p>尽管我们已经有了数据，但是opengl并不能直接使用他们。opengl对于可以读取的内存区域是有一定限制的。你可以自己给顶点分配内存空间，但是opengl并不能直接看到这些内存。因此，我们需要做的第一步事情就是分配一个opengl可见的内存空间，然后将我们的数据填充到里面。这个创建的对象叫做“缓存对象（buffer object）”。</p>
<p>缓存的对象是一个线性的存储空间，受opengl管理和分配。这个内存空间中的内容是受用户控制的，但是用户只有间接的访问能力。可以将这些缓存对象想象成GPU的内存。GPU可以很快的从这个内存中读取内容，因此将数据存储到这里面，是有性能优势的。</p>
<p>本章中的缓存对象是在初始话的时候创建的。如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">void InitializeVertexBuffer()
{
    glGenBuffers(1, &amp;positionBufferObject);

    glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexPositions), vertexPositions, GL_STATIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
}
</code></pre></td></tr></table>
</div>
</div><p>第一行用来创建缓存对象，并将句柄存储到全局变量<code>positionBufferObject</code>中。这个对象被创建出来了，但是还没有被分配任何的内存空间。</p>
<p><code>glBindBuffer</code>函数将新创建的缓存对象绑定到<code>GL_ARRAY_BUFFER</code>。正如在前面简介中介绍的，opengl中的对象通常必须被绑定到上下文，这样opengl在渲染的时候才会用到这些对象。</p>
<p><code>glBufferData</code>函数进行了两个操作，内存分配和内容拷贝。它为当前绑定到<code>GL_ARRAY_BUFFER</code>对象分配内存。通过<code>sizeof(vertexPositions)</code>获取分配内存的大小，然后将<code>vertexPosition</code>对应大小的内存内容拷贝到<code>glBufferData</code>为对象分配的内存中。简单的来讲，可以理解为我们已经拥有了内存中存储的特定大小的数组，然后需要在GPU中分配相应大小的内存空间，最后，将内存拷贝到GPU中的内存中。</p>
<p><code>glBufferData</code>第四个参数的含义将会在后面的内容中给出解释。</p>
<p>第二个绑定操作是起到清理作用。将上下文中<code>GL_ARRAY_BUFFER</code>绑定到0,也就是说先前绑定的对象将会被解绑。这个操作从严格意义上来讲并不是必须的。因为，后续的绑定操作，会对当前的对象解绑。但是，进行解绑操作还是一个很好的习惯，除非你对渲染过程有个严格的控制。</p>
<p>通过上述的步骤，我们实现了顶点数据到GPU内存的传输。但是，我们仅仅分配了一定大小的内存，然后用二进制进行填充，opengl并不知道内存中数据的格式。因此，我们需要告诉opengl怎么处理这些存储的数据。</p>
<p>在渲染的代码里我们做了如下操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
glEnableVertexAttribArray(0);
glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);
</code></pre></td></tr></table>
</div>
</div><p>第一个函数我们之前已经说明过了，就是让opengl上下文使用buffer对象。第二个函数，<code>glEnableVertexAttribArray</code>将在下一节进行介绍，如果没有这个函数那么第三个函数就不重要了。</p>
<p>第三个函数是最为关键的函数。<code>glVertexAttribPointer</code>这个函数里面虽然后Pointer单词，但是它并不是用来处理指针的。而是用来处理缓存对象的。</p>
<p>当渲染发生的时候，opengl会将缓存对象中存储的数据取出来。接着，我们需要告诉opengl的是，这些顶点的数据存储的格式是怎么样的。也就是说，我们需要告诉opengl怎么去识别buffer中存储的数据。</p>
<p>在上面的例子中，我们的数据格式是这样的：</p>
<ul>
<li>我们的位置数据是以32位浮点型数据（c/c++中的float）</li>
<li>顶点的每一个位置都有4个数字组成</li>
<li>每个顶点数据之间没有空余空间。是在数组中紧密排列的。</li>
<li>数组中的第一个值是缓存对象中的起点位置。</li>
</ul>
<p><code>glVertexAttribPointer</code>将上述四个信息都告诉了opengl。函数的第三个参数是数据中每个值的基本类型，在这个例子中是<code>GL_FLOAT</code>，表示32位浮点型。第二个参数表示了有多少个基本类型的数据可以组成一个小的单元，这里是4个。第五个参数用来表示每组数值之间的间隔。在这个例子中，每组数值之间没有间隔，因此这个值是0。第六个参数表示缓存对象的起始的字节偏移量，0表示在缓存对象的起端。</p>
<p>第四个参数会在接下去的章节中介绍。第一个参数会在下面一节中介绍。</p>
<p>这里有一点看上去被忽略的事情是，数据来自于哪个缓存对象。这一点是隐含的。<code>glVertexAttribPointer</code>总是绑定到之前绑定到<code>GL_ARRAY_BUFFER</code>缓存对象上。因此，函数中没有说明缓存对象的句柄，直接使用了先前绑定的句柄。</p>
<p>这个函数在接下去的章节中会给出详细介绍。</p>
<p>现在opengl知道从哪里获取顶点数据，于是可以使用下面的函数进行渲染。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">glDrawArrays(GL_TRIANGLES, 0, 3);
</code></pre></td></tr></table>
</div>
</div><p>这个函数表面上看起来非常简单，但是它干了很多活。第二个和第三个参数分别表示从顶点数据中读取的初始位置以及个数。0,3就表示被处理的顶点为0,1,2。</p>
<p>第一个参数用来告诉opengl，从顶点中读取的三个数值是用来绘制三角形的。</p>
<h3 id="heading-4">顶点处理和着色器</h3>
<p>现在我们已经告诉opengl顶点数据有哪些了，渲染管线的下一个步骤是顶点的处理。这是本章中介绍的两个可编程阶段中的一个，这涉及到着色器的使用。</p>
<p>着色器是运行在gpu上的一个程序。在渲染管线中存在几个可能的着色器阶段，并且没一个都有自己的输入和输出。着色器的目的是对输入进行一定的处理，获得想要的输出。</p>
<p>每个着色器都是在一系列的输入下执行的。这里需要强调的是任何阶段的着色器之间是相互独立的。在单独执行着色器的时候不会出现串扰。着色器对于输入和输出是有严格的定义的。着色器在执行完成之后没有对所有的输出赋值的行为在大多数情况下是不合法的。</p>
<p>顶点着色器正如名称所示，是对一系列顶点进行操作的。严格的来讲，每一个顶点着色器的调用都是针对一个顶点的。这些着色器必须输出用户定义的输出和顶点在裁剪坐标系下对应的位置。这个裁剪坐标系的计算逻辑完全由顶点着色器控制。</p>
<p>opengl中的着色器由opengl着色器语言编写的（GLSL）。这个语言看上去很想C语言，但是和C还是有很大区别的。相对于C语言而言，GLSL有很多的限制，如不能有递归的逻辑等。下面我们给出了顶点着色器的示例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#version 330

layout(location = 0) in vec4 position;
void main()
{
    gl_Position = position;
}
</code></pre></td></tr></table>
</div>
</div><p>上面的代码看上去是非常简单的。第一行表示了这个着色器使用的GLSL的版本是3.30。所有的GLSL着色器都需要声明版本号。</p>
<p>接下去的一行定义了顶点着色器的输入。输入变量的名字为<code>position</code>，类型是<code>vec4</code>：一个四维的浮点型向量。这一句话也说明了变量的布局位置是0,这个在下面会给出更多的解释。</p>
<p>和C语言类似的是，着色器的执行也都是从<code>main</code>函数的调用开始的。这个着色器非常简单，仅仅实现了将输入<code>position</code>的值拷贝给<code>gl_Position</code>的变量。这个变量没有在着色器中定义；因为它是一个在每个着色器中都事先定义好了的标准变量。如果在GLSL代码中发现一个变量是以<code>gl_</code>开始的，那么这个变量一定是内置的变量。在自己对变量生命定义的时候，是不允许使用<code>gl_</code>作为开头的。</p>
<p><code>gl_Position</code>的定义类似如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">out vec4 gl_Position;
</code></pre></td></tr></table>
</div>
</div><p>顶点着色器至少需要做的事情是产生顶点对应的裁剪坐标系下的位置。<code>gl_Position</code>正是顶点在裁剪坐标系中的位置。因此，此处输入的顶点已经是裁剪坐标系下的点了，这个着色器就直接将输入的值复制到输出即可。</p>
<p><strong>顶点属性</strong>。着色器有输入输出。可以将这想象成函数的入参和返回值。如果一个着色器是一个函数，那么它被调用的时候会有一系列的入参，并且期望得到一系列的输出。</p>
<p>着色器的输入和输出都分别有自己的来源和去处。因此，入参<code>position</code>必须在一开始附上来自某个地方的数值。那么这些数值从什么地方来的呢？装载这些数值的地方叫做顶点属性。</p>
<p>你也许会发现“vertex attribute”这两个词好像在哪里出现过。不错，就在<code>glEnableVertexAttribArray</code>和<code>glVertexAttribPointer</code>两个函数中带有这两个词。</p>
<p>这说明了数据是怎么在opengl管线中传输的。当渲染开始的时候，缓存对象中的顶点数据的读取和设定由函数<code>glVertexAttribPointer</code>函数完成。这个函数描述了数据从什么地方来的。通过<code>glVertexAttribPointer</code>函数将数据和顶点着色器中的变量名字联系在一起的具体实现是比较复杂的。</p>
<p>顶点着色器中的每个输入参数都有一个对应的位置，叫做index属性。正如上文中提到的，入参的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">layout(location = 0) in vec4 position;
</code></pre></td></tr></table>
</div>
</div><p>布局的位置（lcoation）就是变量position的index属性。该属性值必须大于等于0,它的取值范围是和硬件相关的。</p>
<p>在代码里，当指向一个属性的时候，都是通过指向index属性实现的。函数<code>glEnableVertexAttribArray</code>，<code>glDisableVertexAttribArray</code>和<code>glVertexAttribPointer</code>的第一个参数都是index属性。在着色器代码里，我们将position变量的index属性设置为0。因此在调用<code>glEnableVertexAttribArray(0)</code>函数的时候，就是使得<code>position</code>的index属性有效。</p>
<p>下面给除了数据如何传输到顶点着色器的示意图：</p>
<p><img src="./image/hello_triangle_figure1.1.png" alt=""></p>
<p>没有调用<code>glEnableVertexAttribArray</code>，仅仅调用<code>glVertexAttribPointer</code>到那个index是没有意义的。enable函数并不一定要放在<code>glVertexAttribPointer</code>函数调用之前，但是在渲染命令调用前，enable函数必须要被调用。如果这个属性没被enable，那么渲染的时候将不会用到这个属性。</p>
<h3 id="heading-5">光栅化</h3>
<p>到目前已经完成了将3个顶点传递给opengl，并通过顶点着色器将其转换成了裁剪坐标系中的3个位置。接下来，顶点的位置通过将xyz三个分量，分别除以w分量得到标准化设备坐标系中点。在我们的例子中，3个顶点的w分量是1,因此得到的位置已经是标准化设备坐标系中的位置了。</p>
<p>在这之后，顶点位置还需要转换成窗口坐标系中。这个转换过程被成为视图变换。在opengl中对应的函数为glviewport。本章中，窗口大小的变化都会触发该函数的执行。因此本章中reshape函数的实现为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">void reshape(int w, int h)
{
    glViewport(0, 0, (GLsizei)w, (GLsizei)h);
}
</code></pre></td></tr></table>
</div>
</div><p>这个告诉opengl窗口的哪个区域是可以用于渲染的。在这个例子中，我们将整个窗口的可视区域作为渲染区域。如果不调用这个函数，窗口大小的变化就不会对渲染产生影响。同时需要注意的是，上述的代码并没有让渲染保持原来的比例。窗口的收缩和延展会同样影响到三角形的收缩和延展。</p>
<p>glviewport函数调用时，对应的原点位于窗口的左下方。一旦位于窗口坐标系中，opengl可以将三角形的三个顶点通过扫描转换的过程，将三角形转换成一系列的片段。为了完成这样的操作，opengl必须确定这些点表述的是什么。</p>
<p>opengl可以将一系列的点以不同的方式表述。让opengl将点理解成三角形的命令是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">glDrawArrays(GL_TRIANGLES, 0, 3);
</code></pre></td></tr></table>
</div>
</div><p>枚举<code>GL_TRIANGLES</code>告诉opengl一系列输入点中的每三个点用来构建一个三角形。由于我们仅仅传入了3个点，我们只得到了一个三角形。</p>
<p><strong>Figure 1.2. Data Flow to Rasterizer</strong>
<img src="./image/data_flow_to_rasterizer.png" alt=""></p>
<p>如果我们传入的是6个点，那么我们就能够得到2个三角形。</p>
<h3 id="heading-6">片段处理</h3>
<p>片段着色器是用来计算片段的输出颜色。片段着色器的输入包括片段在窗口空间中的xyz坐标位置。输入中也可以包含一些用户定义的数据。</p>
<p>这里我们使用的片段着色器类似如下：</p>
<p><strong>Example 1.5. Fragment Shader</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#version 330

out vec4 outputColor;
void main()
{
    outputColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);
}
</code></pre></td></tr></table>
</div>
</div><p>第一行与顶点着色器相同，都是用来表示着色器使用的GLSL语言的版本。第二行代码表示的是片段着色器的输出。输出参数的类型是vec4。</p>
<p>main函数中说明了这个片段着色器的输出是一个分量都为1的四维向量。这样创建得到的是一个白色的三角形。第四个维度表示的是透明度的意思。由于所有的片段着色器输出的点都是对应到窗口坐标系中的，因此这里不需要在对其进行赋值等操作。</p>
<p><strong>Note</strong></p>
<blockquote>
<p>在顶点着色器一节中，我们使用了<code>layout (location=#)</code>的表达式的目的是用来提供顶点着色器输入和顶点index属性值之间的关联。这个为了将顶点数组和顶点着色器中的输入关联起来。因此，你接下来会对片段着色器的输出和屏幕中的点之间的关联产生一定的疑惑。
opengl能够自己进行处理。因为，对于片段着色器输出的位置是唯一确定的，如当前图像要被渲染到屏幕。正因为这样，如果你定义一个片段着色器的输出，那么这个输出值会自动的输出到目标位置的图像中。对于不同的片段着色器的结果输出到不同的图像上是可能的，这样会增加一些复杂度，他的实现也会和输入的处理方式类似。但这里不会对此进行更详细的说明。</p>
</blockquote>
<h2 id="heading-7">生成着色器</h2>
<p>这里我们将会说明，着色器的相关代码如何传递给opengl，并让它识别的。</p>
<p>着色器语言是用类c语言编写的。因此，opengl对着色器语言的处理方式也类似与对c语言的处理方式。在c语言中，单独的c文件被编译成目标文件，然后，一个或多个目标文件通过链接的方式，生成单个项目，或是动态，静态库。opengl的处理方式非常类似。</p>
<p>一个着色器语言首先被编译成着色器目标对象，然后一个或多个着色器目标对象通过链接的方式生成项目对象。</p>
<p>opengl项目对象包含了用于渲染操作的所有着色器。在本章的示例中，我们有顶点着色器和片段着色器；他们两者通过链接的方式共同组成了项目对象。具体实现的方式类似如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">void InitializeProgram()
{
    std::vector&lt;GLuint&gt; shaderList;

    shaderList.push_back(CreateShader(GL_VERTEX_SHADER, strVertexShader));
    shaderList.push_back(CreateShader(GL_FRAGMENT_SHADER, strFragmengShader));

    theProgram = CreateProgram(shaderList);

    std::for_each(shaderList.begin(), shaderList.end(), glDeleteShader);
}
</code></pre></td></tr></table>
</div>
</div><p>第一个语句创建的对象用于存储将要被链接的着色器目标。接下去的两条语句将两条着色器代码进行了编译。最后通过CreateProgram将两个着色器目标进行链接，生成项目对象。CreateShader代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">GLuint CreateShader(GLenum eShaderType, const std::string&amp; strShader)
{
    GLuint shader = glCreateShader(eShaderType);
    const char *pStrShader = strShader.c_str();
    glShaderSource(shader, 1, &amp;pStrShader, NULL);

    glCompileShader(shader);

    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;status);
    if (status == GL_FALSE)
    {
        GLint infoLogLength;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;infoLogLength);

        GLchar *strInfoLog = new GLchar[infoLogLength+1];
        glGetShaderInfoLog(shader, infoLogLength, NULL, strInfoLog);
        
        const char *strShaderType = NULL;
        switch(eShaderType)
        {
        case GL_VERTEX_SHADER: strShaderType = &#34;vertex&#34;; break;
        case GL_GEOMETRY_SHADER: strShaderType = &#34;geometry&#34;; break;
        case GL_FRAGMENT_SHADER: strShaderType = &#34;fragment&#34;; break;

        }
        fprintf(stderr, &#34;Compile failure in %s shader:\n%s\n&#34;, strShaderType, strInfoLog);
        delete[] strInfoLog;
    }
    return shader;
}
</code></pre></td></tr></table>
</div>
</div><p>首先告诉opengl，需要创建什么类型的对象，由<code>glCreateShader</code>完成。这个函数可以创建特定类型的纹理对象，如顶点或是片段纹理，因此该函数的入参是纹理对象的类型。由于不同版本的着色器语言会有不同的格式规则，以及对应的预先定义的变量和常量，因此在着色器语言的字符串中首先必须要有说明对应的版本。这样编译器才会知道采用怎样的方式对其进行编译。</p>
<p><strong>Note</strong></p>
<blockquote>
<p>着色器和程序对象都是opengl中的对象。但是，他们的创建方式等和其他的opengl对象有显著的区别。比如，对于缓存对象，它的创建是通过类似与“glGenBuffer”的形式创建的。除此之外还有其他很多的不同之处。</p>
</blockquote>
<p>上述代码中的下一个阶段是通过<code>glShaderSource</code>将等待编译的着色器语句导入到创建的着色器对象中。该函数的第一个参数是着色器对象，第二个参数是有多少个字符串会被载入到着色器对象。将多个字符串载入到一个纹理对象中，类似于c语言中，将头文件合并到c文件中。第三个参数是将要被载入的字符串数组，最后一个参数是字符串长度的数组，这里传入NULL，表示我们传入的字符串都是以null结尾的。通常情况下，最后一个参数传入NULL就可以了，除非你需要在字符串中使用null字符，才需要传入字符串的长度。</p>
<p>一旦这些字符串在对象中时，他们就可以通过glCompileShader对着色器进行编译。</p>
<p>当编译以后，需要查看编译是否成功。这里，我们使用了<code>glGetShaderiv</code>来获取GL_COMPILE_STATUS。如果返回的是GL_FALSE，那么编译就是失败了;否则编译就是成功了。</p>
<p>当编译失败的时候，我们会将错误打印出来。它将消息输出到stderr，解释编译失败的原因。这个错误就类比于c编译器报的错误。</p>
<p>当创建的着色器对象都编译成功后，我们将其传入到CreateProgram函数中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">GLuint CreateProgram(const std::vector&lt;GLuint&gt; &amp;shaderList)
{
    GLuint program = glCreateProgram();

    for (size_t iLoop=0; iLoop&lt;shaderList.size(); ++iLoop)
        glAttachShader(program, shaderList[iLoop]);

    glLinkProgram(program);

    GLint status;
    glGetProgramiv(program, GL_LINK_STATUS, &amp;status);
    if (status == GL_FALSE)
    {
        GLint infoLogLength;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;infoLogLength);
        
        GLchar *strInfoLog = new GLchar[infoLogLength+1];
        glGetProgramInfoLog(program, infoLogLength, NULL, strInfoLog);
        fprintf(stderr, &#34;Linker failure: %s\n&#34;, strInfoLog);
        delete[] strInfoLog;
    }

    for (size_t iLoop=0; iLoop&lt;shaderList.size(); ++iLoop)
        glDetachShader(program, shaderList[iLoop]);

    return program;
}
</code></pre></td></tr></table>
</div>
</div><p>这个函数是相当简单的。首先用<code>glCreateProgram</code>创建空的项目对象。这个函数没有入参。项目对象是所有着色器集合而成的。其次，将所有的创建的着色器通过<code>glAttachShader</code>对象挂载到项目对象中。在挂载的时候，并不需要指出各个着色器对象的类型。</p>
<p>当所有的着色器对象都挂载到项目对象后，通过<code>glLinkProgram</code>将代码进行链接。与先前的处理方式类似。我们必须通过调用<code>glGetProgramiv</code>获取对象链接是否成功。如果链接失败，则输出错误日志，否则返回创建了的项目对象。</p>
<p><strong>Note</strong></p>
<blockquote>
<p>在上述着色器对象中，顶点着色器中的输入<code>position</code>的属性位置是着色器自动赋值的。其它的属性需要通过<code>layout(location=#)</code>的方式赋值。如果，你忘了对属性的index进行赋值，opengl会自动进行赋值。因此，你可能并不知道一个属性的index。如果你需要查询属性的位置，你可以通过<code>glGetAttribLocation</code>获取。</p>
</blockquote>
<p>当整个项目成功链接之后，你可以通过<code>glDeatchShader</code>将挂载的着色器对象从项目对喜爱那个中删除。项目对象的状态和功能并不会收到影响。这样做的作用是告诉opengl这些着色器对象对于项目对象而言没有作用了。</p>
<p>在项目对象链接之后，还需要将其他的着色器对象彻底删除，使用的函数是<code>glDeleteShader</code>。</p>
<p><strong>项目对象的使用</strong>。在opengl开始渲染的时候，需要告诉opengl执行哪个项目对象，这是需要调用<code>glUseProgram</code>函数。在本章的例子中，我们在display函数中调用了两次该函数。第一次传入的参数是<code>theProgram</code>，第二次入参是0,告诉opengl没有项目对象用于渲染了。</p>
<h2 id="heading-8">清理工作</h2>
<p>本章的例子中创建了很多opengl资源。它分配了缓存对象（占用显存资源）。创建了两个着色器对象，和一个项目对象，这些对象都是存储在opengl的内存中。但是，我们到目前为止仅仅删除了着色器对象。</p>
<p>在这个例子中，并不需要进行额外的清理工作。因为当opengl工作的窗口被关闭的时候，这些资源会被opengl释放。</p>
<p>但是，通常意义上而言，在关掉opengl之前，将这些对象进行释放，是一个比较好的习惯。如果，你将对象放在c++对象中，那么在析够函数中可以将这些资源进行释放。</p>
<h2 id="heading-9">回顾</h2>
<ul>
<li>缓存对象是opengl分配的现行内存空间，用来存储顶点数值</li>
<li>glsl语言编写的着色器被编译成着色器对象，然后通过链接产生项目对象，项目对象将在渲染过程中执行。</li>
<li><code>glDrawArrays</code>函数用来绘制三角形，使用当前绑定到buffer对象中的点进行渲染。</li>
</ul>
<h3 id="opengl">opengl函数</h3>
<p>glClearColor，glClear：设置清空屏幕的颜色，当glClear调用GL_COLOR_BUFFER_BIT的时候，使用设定的颜色进行清屏。</p>
<p>glGenBuffers,glBindBuffer,glBufferData：这些函数用来创建和操作缓存对象。glGenBuffers创建一个或多个缓存对象，<code>glBindBuffer</code>将创建的对象绑定到上下文特定的位置，<code>glBufferData</code>用来分配内存，并将特定的数据存入到分配的内存中。</p>
<p>glEnableVertexAttribArray,glDisableVertexAttribArray,glVertexAttribPointer：这些函数用来控制顶点属性数组。<code>glEnableVertexAttribArray</code>用来激活属性index，<code>glDisableVertexAttribArray</code>用来disable激活的属性index，<code>glVertexAttribPointer</code>用来定义顶点数据格式，和具体位置，告诉opengl如何解析缓存对想中的定点数据。</p>
<p>glDrawArrays：用来执行渲染，使用当前激活的顶点属性，以及当前的项目对象。这个函数导致一系列的定点按照一定的顺序进行绘制。</p>
<p>glViewPort：这个函数定义了当前的视口变换。定义了窗口的显示区域。</p>
<p>glCreateShader, glShaderSource, glCompileShader, glDeleteShader：这些函数是用来创建纹理项目对象。<code>glCreateShader</code>用来创建特定类型的空的纹理对象。<code>glShaderSource</code>将特定的纹理语言字符串设定到特定纹理对象;多次调用该函数会将原先设定的纹理内容覆盖。<code>glCompileShader</code>用来对刚设定的纹理对象进行编译。<code>glDeleteShader</code>将原先的纹理对象删除。</p>
<p>glCreateProgram, glAttachShader, glLinkProgram, glDetachShader：这些函数用来处理项目对象。<code>glCreateProgram</code>创建一个空的项目对象。<code>glAttachShader</code>用来将纹理对象绑定到项目对象上。多次调用该函数可以将多个纹理对象绑定到项目对象。<code>glLinkProgram</code>将所有绑定的纹理对象进行链接操作。<code>glDetachShader</code>用来将项目对象中绑定的纹理对象删除。</p>
<p>glUseProgram：这个函数输入的项目对象设为当前使用的项目。所有发生的渲染操作都是对当前设定的项目所绑定的纹理对象进行操作。如果这个函数的入参设为0,就表示当前没有项目被绑定。</p>
<p>glGetAttribLocation：这个函数使用来获取特定名字的属性的index。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">grassofsky</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2017-05-30
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/opengl/">opengl</a>
          <a href="/tags/learningmodern3dgraphicsprogramming/">LearningModern3DGraphicsProgramming</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/learningmodern3dgraphicsprogramming/3_basic_introduction/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">3. 基础简介</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/learningmodern3dgraphicsprogramming/5_playing_with_colors/">
            <span class="next-text nav-default">5. 设置颜色</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:grass-of-sky@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/grassofsky" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/zhong-xie-wei-32" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">grassofsky</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
